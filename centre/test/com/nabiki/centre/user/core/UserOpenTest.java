/*
 * Copyright (c) 2020 Hongbao Chen <chenhongbao@outlook.com>
 *
 * Licensed under the  GNU Affero General Public License v3.0 and you may not use
 * this file except in compliance with the  License. You may obtain a copy of the
 * License at
 *
 *                    https://www.gnu.org/licenses/agpl-3.0.txt
 *
 * Permission is hereby  granted, free of charge, to any  person obtaining a copy
 * of this software and associated  documentation files (the "Software"), to deal
 * in the Software  without restriction, including without  limitation the rights
 * to  use, copy,  modify, merge,  publish, distribute,  sublicense, and/or  sell
 * copies  of  the Software,  and  to  permit persons  to  whom  the Software  is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE  IS PROVIDED "AS  IS", WITHOUT WARRANTY  OF ANY KIND,  EXPRESS OR
 * IMPLIED,  INCLUDING BUT  NOT  LIMITED TO  THE  WARRANTIES OF  MERCHANTABILITY,
 * FITNESS FOR  A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT  SHALL THE
 * AUTHORS  OR COPYRIGHT  HOLDERS  BE  LIABLE FOR  ANY  CLAIM,  DAMAGES OR  OTHER
 * LIABILITY, WHETHER IN AN ACTION OF  CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE  OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package com.nabiki.centre.user.core;

import com.nabiki.centre.user.core.plain.UserState;
import com.nabiki.centre.utils.Utils;
import com.nabiki.objects.*;
import org.junit.Test;

import java.time.LocalDate;
import java.time.LocalTime;

import static org.junit.Assert.*;

public class UserOpenTest extends UserSuperTest {

  @Test
  public void checkInitAccount() {
    // Prepare account.
    prepare();

    // Test user state.
    assertEquals("user state should be load",
        user.getState(), UserState.RENEW);

    // Test account info.
    var userAccount = user.getTradingAccount();
    assertEquals(userAccount.PreBalance, account.PreBalance, 0.0);
    assertEquals(userAccount.PreMargin, account.PreMargin, 0.0);
    assertEquals(userAccount.PreCredit, account.PreCredit, 0.0);
    assertEquals(userAccount.PreDeposit, account.PreDeposit, 0.0);
  }

  @Test
  public void open() {
    prepare();

    var order = new CInputOrder();
    order.InstrumentID = "c2101";
    order.BrokerID = "9999";
    order.ExchangeID = "DCE";
    order.LimitPrice = 2120;
    order.VolumeTotalOriginal = 10;
    order.CombOffsetFlag = CombOffsetFlagType.OFFSET_OPEN;
    order.Direction = DirectionType.DIRECTION_SELL;

    var active = new ActiveUser(user, provider, global);
    var uuid = active.insertOrder(order);

    // Test order exec state.
    var rspInfo = active.getExecRsp(uuid);
    assertEquals(rspInfo.ErrorID, ErrorCodes.NONE);

    // Test frozen volume.
    var frz = active.getFrozenAccount(uuid);
    assertEquals(frz.getFrozenVolume(), order.VolumeTotalOriginal, 0.0D);

    // Test frozen cash.
    var cash = frz.getSingleFrozenCash();
    var frzCash = order.LimitPrice
        * global.getInstrInfo("c2101").Instrument.VolumeMultiple
        * global.getInstrInfo("c2101").Margin.ShortMarginRatioByMoney;
    var frzCommission
        = global.getInstrInfo("c2101").Commission.OpenRatioByVolume;
    assertEquals(cash.FrozenCash, frzCash, 0.0);
    assertEquals(cash.FrozenCommission, frzCommission, 0.0);

    // Test account.
    var userAccount = active.getTradingAccount();
    assertEquals(userAccount.CurrMargin, account.PreMargin, 0.0);
    assertEquals(userAccount.FrozenCash,
        frzCash * order.VolumeTotalOriginal, 0.0);
    assertEquals(userAccount.FrozenCommission,
        frzCommission * order.VolumeTotalOriginal, 0.0);
    assertEquals(userAccount.FrozenMargin, 0.0, 0.0);
    assertEquals(
        userAccount.Available,
        userAccount.Balance - userAccount.CurrMargin
            - (frzCash + frzCommission) * order.VolumeTotalOriginal,
        0.0);
  }

  @Test
  public void open_fail() {
    prepare();

    var order = new CInputOrder();
    order.InstrumentID = "c2101";
    order.BrokerID = "9999";
    order.ExchangeID = "DCE";
    // Test bad price.
    order.LimitPrice = 5000;
    order.VolumeTotalOriginal = 10;
    order.CombOffsetFlag = CombOffsetFlagType.OFFSET_OPEN;
    order.Direction = DirectionType.DIRECTION_SELL;

    var active = new ActiveUser(user, provider, global);
    var uuid = active.insertOrder(order);

    // Check order exec state.
    var rspInfo = active.getExecRsp(uuid);
    assertEquals(rspInfo.ErrorID, ErrorCodes.BAD_FIELD);

    // Test bad volume.
    order.LimitPrice = 2120;
    order.VolumeTotalOriginal = Integer.MAX_VALUE;

    active = new ActiveUser(user, provider, global);
    uuid = active.insertOrder(order);

    // Check order exec state.
    rspInfo = active.getExecRsp(uuid);
    assertEquals(rspInfo.ErrorID, ErrorCodes.BAD_FIELD);

    // Test insufficient money.
    order.LimitPrice = 2120;
    order.VolumeTotalOriginal = 5000;

    active = new ActiveUser(user, provider, global);
    uuid = active.insertOrder(order);

    // Check order exec state.
    rspInfo = active.getExecRsp(uuid);
    assertEquals(rspInfo.ErrorID, ErrorCodes.INSUFFICIENT_MONEY);
  }

  @Test
  public void open_rtn() {
    prepare();

    var order = new CInputOrder();
    order.InstrumentID = "c2101";
    order.BrokerID = "9999";
    order.ExchangeID = "DCE";
    order.LimitPrice = 2120;
    order.VolumeTotalOriginal = 10;
    order.CombOffsetFlag = CombOffsetFlagType.OFFSET_OPEN;
    order.CombHedgeFlag = CombHedgeFlagType.SPECULATION;
    order.Direction = DirectionType.DIRECTION_SELL;

    var active = new ActiveUser(user, provider, global);
    var uuid = active.insertOrder(order);

    // Sleep and wait for the thread to take request.
    sleep(1000);

    var orderRefs = provider.getMapper().getOrderRef(uuid);
    assertEquals(orderRefs.size(), 1);

    // Get order ref.
    var orderRef = orderRefs.iterator().next();

    // Construct rtn order.
    var rtnOrder = new COrder();
    rtnOrder.InstrumentID = "c2101";
    rtnOrder.ExchangeInstID = "c2101";
    rtnOrder.ExchangeID = "DCE";
    rtnOrder.OrderRef = orderRef;
    rtnOrder.OrderLocalID = "test_order_local_id";
    rtnOrder.OrderSysID = "test_order_sys_id";
    rtnOrder.LimitPrice = order.LimitPrice;
    rtnOrder.VolumeTotalOriginal = order.VolumeTotalOriginal;
    rtnOrder.VolumeTraded = 0;
    rtnOrder.VolumeTotal = rtnOrder.VolumeTotalOriginal;
    rtnOrder.Direction = order.Direction;
    rtnOrder.CombOffsetFlag = order.CombOffsetFlag;
    rtnOrder.CombHedgeFlag = order.CombHedgeFlag;
    rtnOrder.OrderSubmitStatus = OrderSubmitStatusType.ACCEPTED;
    rtnOrder.OrderStatus = OrderStatusType.NO_TRADE_QUEUEING;
    rtnOrder.InsertDate = Utils.getDay(LocalDate.now(), null);
    rtnOrder.InsertTime = Utils.getTime(LocalTime.now(), null);
    rtnOrder.UpdateTime = Utils.getTime(LocalTime.now(), null);
    rtnOrder.TradingDay = global.getTradingDay();

    // Update rtn order.
    provider.whenRtnOrder(rtnOrder);

    // Construct a traded return order.
    rtnOrder.VolumeTraded = 3;
    rtnOrder.VolumeTotal = rtnOrder.VolumeTotalOriginal - rtnOrder.VolumeTraded;
    rtnOrder.OrderStatus = OrderStatusType.PART_TRADED_QUEUEING;
    rtnOrder.UpdateTime = Utils.getTime(LocalTime.now(), null);

    // Update order again.
    provider.whenRtnOrder(rtnOrder);

    // Check rtn order.
    assertEquals(active.getRtnOrder(uuid).size(), 1);

    var rtnOrder0 = active.getRtnOrder(uuid).iterator().next();
    assertNotNull(rtnOrder0);
    assertEquals(rtnOrder0.UpdateTime, rtnOrder.UpdateTime);

    // Construct rtn trade.
    var rtnTrade = new CTrade();
    rtnTrade.InstrumentID = "c2101";
    rtnTrade.ExchangeInstID = "c2101";
    rtnTrade.ExchangeID = "DCE";
    rtnTrade.OrderRef = orderRef;
    rtnTrade.OrderLocalID = "test_order_local_id";
    rtnTrade.OrderSysID = "test_order_sys_id";
    rtnTrade.Price = order.LimitPrice;
    rtnTrade.Volume = 3;
    rtnTrade.Direction = order.Direction;
    rtnTrade.OffsetFlag = order.CombOffsetFlag;
    rtnTrade.HedgeFlag = order.CombHedgeFlag;
    rtnTrade.TradingDay = Utils.getDay(tradingDay, null);
    rtnTrade.TradeTime = Utils.getTime(LocalTime.now(), null);
    rtnTrade.TradeDate = Utils.getDay(LocalDate.now(), null);

    // Update rtn trade.
    provider.whenRtnTrade(rtnTrade);

    // Check rtn trade.
    // Test frozen volume.
    var frz = active.getFrozenAccount(uuid);
    assertEquals(frz.getFrozenVolume(), rtnOrder.VolumeTotal, 0.0D);

    var userAccount = active.getTradingAccount();

    // Test frozen cash.
    var frzCash = order.LimitPrice
        * global.getInstrInfo("c2101").Instrument.VolumeMultiple
        * global.getInstrInfo("c2101").Margin.ShortMarginRatioByMoney;
    var frzCommission
        = global.getInstrInfo("c2101").Commission.OpenRatioByVolume;

    // Calculate used margin for new open position.
    var settlePrice = global.getDepthMarketData("c2101").PreSettlementPrice;
    var volumeMultiple = global.getInstrInfo("c2101").Instrument.VolumeMultiple;
    var marginRate = global.getInstrInfo("c2101").Margin.ShortMarginRatioByMoney;
    var singleMargin = settlePrice * volumeMultiple * marginRate;

    // Check fields.
    assertEquals(userAccount.FrozenCash,
        frzCash * rtnOrder.VolumeTotal, 0.0);
    assertEquals(userAccount.FrozenCommission,
        frzCommission * rtnOrder.VolumeTotal, 0.0);
    assertEquals(userAccount.FrozenMargin, 0.0, 0.0);
    assertEquals(userAccount.CurrMargin,
        singleMargin * rtnOrder.VolumeTraded + userAccount.PreMargin,
        0.0);
    assertEquals(
        userAccount.Available,
        userAccount.Balance - userAccount.CurrMargin
            - (frzCash + frzCommission) * rtnOrder.VolumeTotal,
        0.0);

    // Complete trades.
    // Construct a traded return order.
    rtnOrder.VolumeTraded = rtnOrder.VolumeTotalOriginal;
    rtnOrder.VolumeTotal = 0;
    rtnOrder.OrderStatus = OrderStatusType.ALL_TRADED;
    rtnOrder.UpdateTime = Utils.getTime(LocalTime.now(), null);

    // Update order again.
    provider.whenRtnOrder(rtnOrder);

    // Check rtn order.
    assertEquals(active.getRtnOrder(uuid).size(), 1);

    rtnOrder0 = active.getRtnOrder(uuid).iterator().next();
    assertNotNull(rtnOrder0);
    assertEquals(rtnOrder0.VolumeTraded, rtnOrder.VolumeTotalOriginal);

    // Construct trade.
    rtnTrade.Volume = rtnOrder.VolumeTotalOriginal - rtnTrade.Volume;
    rtnTrade.TradeTime = Utils.getTime(LocalTime.now(), null);
    rtnTrade.TradeDate = Utils.getDay(LocalDate.now(), null);

    // Update trade.
    provider.whenRtnTrade(rtnTrade);

    // Test frozen volume.
    frz = active.getFrozenAccount(uuid);
    assertEquals(frz.getFrozenVolume(), 0, 0.0D);

    userAccount = active.getTradingAccount();

    // Test frozen cash.
    assertEquals(userAccount.FrozenCash, 0, 0.0);
    assertEquals(userAccount.FrozenCommission, 0, 0.0);
    assertEquals(userAccount.FrozenMargin, 0.0, 0.0);
    assertEquals(userAccount.CurrMargin,
        singleMargin * order.VolumeTotalOriginal + userAccount.PreMargin,
        0.0);
    assertEquals(userAccount.Commission, frzCommission * order.VolumeTotalOriginal, 0.0);
    assertEquals(
        userAccount.Available,
        userAccount.Balance - userAccount.CurrMargin,
        0.0);

    // Suppose exception.
    try {
      provider.whenRtnTrade(rtnTrade);
      fail("should throw exception");
    } catch (Throwable ignored) {
    }
  }

  @Test
  public void open_rtn_cancel() {
    prepare();

    var order = new CInputOrder();
    order.InstrumentID = "c2101";
    order.BrokerID = "9999";
    order.ExchangeID = "DCE";
    order.LimitPrice = 2120;
    order.VolumeTotalOriginal = 10;
    order.CombOffsetFlag = CombOffsetFlagType.OFFSET_OPEN;
    order.CombHedgeFlag = CombHedgeFlagType.SPECULATION;
    order.Direction = DirectionType.DIRECTION_SELL;

    var active = new ActiveUser(user, provider, global);
    var uuid = active.insertOrder(order);

    // Sleep and wait for the thread to take request.
    sleep(1000);

    var orderRefs = provider.getMapper().getOrderRef(uuid);
    assertEquals(orderRefs.size(), 1);

    // Get order ref.
    var orderRef = orderRefs.iterator().next();

    // Construct rtn order.
    var rtnOrder = new COrder();
    rtnOrder.InstrumentID = "c2101";
    rtnOrder.ExchangeInstID = "c2101";
    rtnOrder.ExchangeID = "DCE";
    rtnOrder.OrderRef = orderRef;
    rtnOrder.OrderLocalID = "test_order_local_id";
    rtnOrder.OrderSysID = "test_order_sys_id";
    rtnOrder.LimitPrice = order.LimitPrice;
    rtnOrder.VolumeTotalOriginal = order.VolumeTotalOriginal;
    rtnOrder.VolumeTraded = 0;
    rtnOrder.VolumeTotal = rtnOrder.VolumeTotalOriginal;
    rtnOrder.Direction = order.Direction;
    rtnOrder.CombOffsetFlag = order.CombOffsetFlag;
    rtnOrder.CombHedgeFlag = order.CombHedgeFlag;
    rtnOrder.OrderSubmitStatus = OrderSubmitStatusType.ACCEPTED;
    rtnOrder.OrderStatus = OrderStatusType.NO_TRADE_QUEUEING;
    rtnOrder.InsertDate = Utils.getDay(LocalDate.now(), null);
    rtnOrder.InsertTime = Utils.getTime(LocalTime.now(), null);
    rtnOrder.UpdateTime = Utils.getTime(LocalTime.now(), null);
    rtnOrder.TradingDay = global.getTradingDay();

    // Update rtn order.
    provider.whenRtnOrder(rtnOrder);

    // Construct a traded return order.
    rtnOrder.VolumeTraded = 3;
    rtnOrder.VolumeTotal = rtnOrder.VolumeTotalOriginal - rtnOrder.VolumeTraded;
    rtnOrder.OrderStatus = OrderStatusType.PART_TRADED_QUEUEING;
    rtnOrder.UpdateTime = Utils.getTime(LocalTime.now(), null);

    // Update order again.
    provider.whenRtnOrder(rtnOrder);

    // Check rtn order.
    assertEquals(active.getRtnOrder(uuid).size(), 1);

    var rtnOrder0 = active.getRtnOrder(uuid).iterator().next();
    assertNotNull(rtnOrder0);
    assertEquals(rtnOrder0.UpdateTime, rtnOrder.UpdateTime);

    // Construct rtn trade.
    var rtnTrade = new CTrade();
    rtnTrade.InstrumentID = "c2101";
    rtnTrade.ExchangeInstID = "c2101";
    rtnTrade.ExchangeID = "DCE";
    rtnTrade.OrderRef = orderRef;
    rtnTrade.OrderLocalID = "test_order_local_id";
    rtnTrade.OrderSysID = "test_order_sys_id";
    rtnTrade.Price = order.LimitPrice;
    rtnTrade.Volume = 3;
    rtnTrade.Direction = order.Direction;
    rtnTrade.OffsetFlag = order.CombOffsetFlag;
    rtnTrade.HedgeFlag = order.CombHedgeFlag;
    rtnTrade.TradingDay = Utils.getDay(tradingDay, null);
    rtnTrade.TradeTime = Utils.getTime(LocalTime.now(), null);
    rtnTrade.TradeDate = Utils.getDay(LocalDate.now(), null);

    // Update rtn trade.
    provider.whenRtnTrade(rtnTrade);

    // Cancel order.
    rtnOrder.OrderStatus = OrderStatusType.CANCELED;
    rtnOrder.CancelTime = Utils.getTime(LocalTime.now(), null);

    provider.whenRtnOrder(rtnOrder);

    // Check rtn trade.
    // Test frozen volume.
    var frz = active.getFrozenAccount(uuid);
    assertEquals(frz.getFrozenVolume(), 0, 0.0D);

    var userAccount = active.getTradingAccount();

    // Test frozen cash.
    var frzCash = order.LimitPrice
        * global.getInstrInfo("c2101").Instrument.VolumeMultiple
        * global.getInstrInfo("c2101").Margin.ShortMarginRatioByMoney;
    var frzCommission
        = global.getInstrInfo("c2101").Commission.OpenRatioByVolume;

    // Calculate used margin for new open position.
    var settlePrice = global.getDepthMarketData("c2101").PreSettlementPrice;
    var volumeMultiple = global.getInstrInfo("c2101").Instrument.VolumeMultiple;
    var marginRate = global.getInstrInfo("c2101").Margin.ShortMarginRatioByMoney;
    var singleMargin = settlePrice * volumeMultiple * marginRate;

    // Check fields.
    assertEquals(userAccount.FrozenCash, 0, 0.0);
    assertEquals(userAccount.FrozenCommission, 0, 0.0);
    assertEquals(userAccount.FrozenMargin, 0.0, 0.0);
    assertEquals(userAccount.CurrMargin,
        singleMargin * rtnOrder.VolumeTraded + userAccount.PreMargin,
        0.0);
    assertEquals(
        userAccount.Available,
        userAccount.Balance - userAccount.CurrMargin,
        0.0);

    // Suppose exception.
    try {
      provider.whenRtnTrade(rtnTrade);
      fail("should throw exception");
    } catch (Throwable ignored) {
    }
  }
}